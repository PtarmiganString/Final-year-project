### Central .py file with useful functions for Lyapunov process
### All created in Lyapunov proof of concept document

import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
import inspect
import datetime
from scipy.spatial import distance
from sklearn.linear_model import LinearRegression
from scipy.signal import periodogram
from statsmodels.graphics.tsaplots import plot_acf

def calc_mean_period (timeseries):
    """Calculate mean period of time series"""
    
    power_spectrum = periodogram(timeseries)[1]
    frequencies = periodogram(timeseries)[0]

    
    weights = power_spectrum / sum(power_spectrum)
    return 1/np.average(frequencies, weights = weights)




def gen_phase_space_matrix(timeseries, J, m):
    """Convert linear time series to phase space matrix
    
       Arguments:
           timeseries - 1D list of linear timeseries
           J - reconstruction delay/lag
           m - embedding dimension
           
       returns:
           m x M dataframe
    
    """
    
    matrix = pd.DataFrame(columns = np.arange(0,m))
    
    for i, val in enumerate(timeseries):
     
        x_i = []

        for it in range(0, m):
            
            try:
                i_plus_j = timeseries[i + J*it]
                x_i.append(i_plus_j)
            except:
                x_i.append(np.nan)
        
        matrix.loc[i] = x_i
    return matrix





def euc_distance (p1, p2):
    """Find euclidean distance between two multidimensional points 
    
    args:
        p1 - point 1 
        p2 - point 2
        
    returns:
        Euclidean distance - double
    
    """
    try: 
        return distance.euclidean (p1,p2)
    except:
        return np.inf


def find_nearest_neighbour (dataframe, ref_index, mean_period, i_max = 25):
    """ 
    Find nearest neighbour of a row in given dataframe
    
    args:
        dataframe - dataframe used
        ref_index - index of row to find nearest neighbour of
        mean_period - mean period of timeseries
        i_max - ensures nearest neighbour is not too near the end of the timeseries to calculate divergence up to i_max
        
    returns:
        index of nearest neighbour row
    
    """
    dists = []
    ref_row = dataframe.iloc[ref_index, :]
        
    for i in range(0,dataframe.shape[0] - i_max):
        test_row = dataframe.iloc[i, :]
                
#         print("not equal = ",i != ref_index)  
#         print("mean period = ",abs(i-ref_index) > mean_period)  
#         print("combined = ",i != ref_index and abs(i-ref_index) > mean_period)  
#         print("")
            
        if i != ref_index and abs(i-ref_index) > mean_period:
            dist = euc_distance(ref_row, test_row)
        else:
            dist = np.inf
            
        dists.append(dist)
        
    dists = pd.DataFrame(dists,columns = ['euc_distance'])
    dists = dists.sort_values(by = 'euc_distance', ascending = True)                  
    
    return dists.head(1).index.values[0]


def compute_nearest_neighbours(dataframe, mean_period):
    """Generate full array of nearest neighbours for every row in dataframe
    
    args:
        dataframe - dataframe to compute nearest neighbours for
        mean_period - mean period of timeseries
        
    returns:
        array of indices of nearest neighbour pairs
    """
    NN_pairs = []

    for i in range(0,dataframe.shape[0]):
        NN = find_nearest_neighbour(dataframe, ref_index= i, mean_period = mean_period)
        NN_pairs.append([i,NN])
        
    return NN_pairs


def expected_log_distance(dataframe, NN_pairs, i_max = 25): 
    """Compute the divergence of nearest neighbours as a function of i
    
    args:
        dataframe - dataframe to use
        NN_pairs - array of NN indices generated by compute_nearest_neighbours
        i_max - defines how far down the matrix divergence should be measured over
        
    returns:
        2d array of mean log divergence against i for the matrix
    """
    
    dj_data = []
    
    for i in range (0,i_max): # calculate divergence through i_max steps
        
        dj_i = []
    
        for k in range (0,(dataframe.shape[0] - i_max)): # compute for all nearest neighbour pairs 
            
            NN_1 = NN_pairs[k][0]
            NN_2 = NN_pairs[k][1]
            
            p1 = dataframe.iloc[NN_1 + i, :]
            p2 = dataframe.iloc[NN_2 + i, :]
            
            dj_i.append(euc_distance(p1,p2))
                
        
        dj_data.append([i,np.mean(np.log(dj_i))])
        

    return dj_data